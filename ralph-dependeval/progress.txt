## Codebase Patterns

### Project Structure
- Benchmark tasks live in `benchmarks/ccb_*/{task_name}/` with task.toml, instruction.md, environment/, tests/, solution/
- Task selection: `configs/selected_benchmark_tasks.json` (flat JSON array of task objects)
- Instance-to-mirror mapping: `configs/instance_to_mirror.json` (task_name -> sg-benchmarks/repo)
- Config scripts: `configs/*_3config.sh`, common infra in `configs/_common.sh`
- Run logs: `runs/official/` directories

### DependEval Specifics
- Archived tasks at `archive/ccb_dependeval/` — 9 tasks, all scored 0.0
- Archived config at `archive/dependeval_3config.sh`
- Original DependEval data to be cloned to `vendor/DependEval/`
- DependEval content format: `'repo_name/path/file.ext'\n:...code...` with files separated by path headers
- DependEval Task 1 (ME) JSON: has `content`, `called_code_segment`, `invoking_code_segment`, `feature_description`, `detailed_feature_description`, `modified_complete_code` (dict with INCONSISTENT keys: `#file N`, `fileN`, `name.ext`, `path/name.ext`, or raw string for ~15 instances)
- DependEval Task 2 (DR) JSON: has `files` (shuffled list), `content` (concatenated code), `gt` (correctly ordered file list)
- Task 4 (RC) is out of scope — no source code, NL descriptions only

### Harbor Task Format
- task.toml must include time_limit_sec (QA audit C3)
- Dockerfiles must use pinned base images (QA audit C2)
- instruction.md must NOT reference MCP/Sourcegraph/Deep Search (QA audit C1 contamination prevention)
- Evaluation: test.sh runs eval script, writes reward to /logs/verifier/reward.txt
- Agent output: /workspace/submission.json

### Config Patterns
- 3config scripts source _common.sh for run_tasks_parallel, ensure_fresh_token, etc.
- Use --path mode for custom tasks (not --dataset which requires harbor registry)
- Task-to-repo mapping done in config script for MCP runs

### Key Root Cause (from prior analysis)
- DR tasks failed because instruction says "identify all dependencies" (package names) but ground_truth.json contains file ordering (callee-before-caller) — completely different task
- ME tasks may have failed due to ground truth format mismatch: DependEval uses `{"#file 1": "...", "#file 2": "..."}` keyed dict
- All 9 tasks scored 0.0 on Feb 3 baseline run

### Git Gotchas
- Always verify `git symbolic-ref HEAD` before committing — `git branch --show-current` can be misleading after stash operations
- Multiple ralph-* instance dirs exist for different PRDs — make sure vendor/ and ralph-*/ patterns in .gitignore don't conflict across branches

### Manual Steps (NOT in Ralph scope)
- US-005 from PRD: Push materialized repos to sg-benchmarks/ GitHub org and index in Sourcegraph
- US-009 from PRD: Run 3-config validation (baseline + SG_base + SG_full) via harbor

## Progress

## 2026-02-06 - US-001
- Diagnosed all 9 archived DependEval task failures
- Created docs/dependeval_diagnosis.md with per-task-type root cause analysis
- Files changed: docs/dependeval_diagnosis.md (new)
- **Learnings for future iterations:**
  - DR ground truth is actually Android import packages (not file ordering as noted in PRD) — a hybrid that doesn't match DependEval's actual Task 2
  - ME ground truth files contain file dependency pairs (Task 2 DR data), NOT modified_complete_code (Task 1 ME data) — fundamental data loading error
  - ME tasks had TWO failures stacked: Docker build (missing code_content.txt) AND wrong ground truth
  - ME instruction "Problem Statement" section was empty — no feature description extracted from DependEval
  - Agent effort was extremely low on DR/RC tasks (4-31 output tokens, 2-5 tool calls)
  - Run results are at `runs/official/archive/dependeval_opus_20260203_160607/baseline/` (note the archive/ in the path)
  - Result reward field is at `verifier_result.rewards.reward` in result.json
---

## 2026-02-06 - US-002
- Cloned DependEval dataset from https://github.com/ink7-sudo/DependEval to vendor/DependEval/
- Verified all 8 data files exist for 4 languages (python, java, javascript, typescript): task1_*.json (ME) and task2_*_final.json (DR)
- Created vendor/DependEval/data_inventory.json with per-language/task counts, content lengths, example instance IDs
- Added vendor/DependEval/ and vendor/dependeval_repos/ to .gitignore
- Files changed: .gitignore (modified), vendor/DependEval/data_inventory.json (new, gitignored)
- **Learnings for future iterations:**
  - DependEval also has c, c++, c#, php data — we only need python/java/javascript/typescript
  - Instance counts: Python ME=217, Java ME=177, JS ME=208, TS ME=191; DR=180 for all langs
  - ME content lengths are large (avg 8K-32K chars), DR content is smaller (avg 10K-14K chars)
  - DR instances avg 3.4-4.5 files per instance
  - Data also includes task4_*_new.json (RC tasks) — out of scope per US-001 findings
  - The `ralph-*/` gitignore entry gets removed on branch switch — make sure to only modify `.gitignore` on the working branch
---

## 2026-02-06 - US-003
- Built `scripts/select_dependeval_tasks.py` — selects 32 representative DependEval instances
- Selection criteria: content length 2K-20K chars, DR 3+ files, ME non-empty modified_complete_code + feature_description
- Stratified sampling: sorts candidates by content length, picks evenly spaced instances for diversity
- Output: `configs/dependeval_selected_instances.json` mapping instance_id -> {language, task_type, repo_name, content_length, file_count}
- Files changed: scripts/select_dependeval_tasks.py (new), configs/dependeval_selected_instances.json (new)
- **Learnings for future iterations:**
  - After filtering (2K-20K content, 3+ files for DR, non-empty modified_complete_code for ME), candidate counts: Python ME=123, Java ME=80, JS ME=161, TS ME=137; DR=141-157 per lang
  - Java ME has fewest candidates (80) due to larger average content lengths — many exceed 20K char limit
  - ME instances also need feature_description filter — some have empty descriptions which would produce useless instructions
  - `git stash pop` across branches creates merge conflicts for files that exist on one branch but not another — use `git rm` to resolve
  - Always verify `git symbolic-ref HEAD` (not just `git branch --show-current`) before committing — stash operations can leave HEAD on an unexpected branch
---

## 2026-02-06 - US-004
- Built `scripts/materialize_dependeval_repos.py` — extracts source code from DependEval content fields into Git repos
- Parses content format: regex matches `'repo/path/file.ext'` header lines, strips leading `:` from first code line per file
- Creates proper directory trees, initializes Git repo with single commit per instance
- 32 repos materialized to `vendor/dependeval_repos/dependeval-{lang}-{task_type}-{instance_id}`
- Supports --dry-run, --help, --output-dir, --selection flags
- Idempotent: skips existing repos on re-run
- Files changed: scripts/materialize_dependeval_repos.py (new)
- **Learnings for future iterations:**
  - DR content fields may contain FEWER files than the `files` field lists — this is expected. The content has code snippets for dependency analysis, but `files` lists ALL file paths the agent must order
  - Some ME instances have empty files (0 chars) in content — e.g., `pinata.js`, `dropout.py`. These are legitimate (empty starter files the agent must populate)
  - The `modified_complete_code` dict keys in ME data are INCONSISTENT: `#file N` (most common), `fileN`, `name.ext`, or `path/name.ext` — downstream eval scripts must handle all variants
  - Content parsing regex: `^'([^']+/[^']+)'$` — requires at least one `/` in the path to avoid matching code strings with single quotes
  - Git env vars (GIT_AUTHOR_NAME etc.) must be set explicitly since the materialization runs outside any configured Git identity
---
