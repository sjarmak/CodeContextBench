'alexa-apis-for-python/ask-sdk-model/ask_sdk_model/interfaces/amazonpay/request/__init__.py'
:













from __future__ import absolute_import

from .charge_amazon_pay_request import ChargeAmazonPayRequest
from .setup_amazon_pay_request import SetupAmazonPayRequest

'alexa-apis-for-python/ask-sdk-model/ask_sdk_model/interfaces/amazonpay/model/request/billing_agreement_attributes.py'
:














import pprint
import re
import six
import typing
from enum import Enum
from ask_sdk_model.interfaces.amazonpay.model.request.base_amazon_pay_entity import BaseAmazonPayEntity


if typing.TYPE_CHECKING:
    from typing import Dict, List, Optional, Union, Any
    from datetime import datetime
    from ask_sdk_model.interfaces.amazonpay.model.request.billing_agreement_type import BillingAgreementType as BillingAgreementType_33b14792
    from ask_sdk_model.interfaces.amazonpay.model.request.seller_billing_agreement_attributes import SellerBillingAgreementAttributes as SellerBillingAgreementAttributes_4f93d175
    from ask_sdk_model.interfaces.amazonpay.model.request.price import Price as Price_28baad92


class BillingAgreementAttributes(BaseAmazonPayEntity):

    deserialized_types = {
        'platform_id': 'str',
        'seller_note': 'str',
        'seller_billing_agreement_attributes': 'ask_sdk_model.interfaces.amazonpay.model.request.seller_billing_agreement_attributes.SellerBillingAgreementAttributes',
        'billing_agreement_type': 'ask_sdk_model.interfaces.amazonpay.model.request.billing_agreement_type.BillingAgreementType',
        'subscription_amount': 'ask_sdk_model.interfaces.amazonpay.model.request.price.Price',
        'object_type': 'str',
        'version': 'str'
    }

    attribute_map = {
        'platform_id': 'platformId',
        'seller_note': 'sellerNote',
        'seller_billing_agreement_attributes': 'sellerBillingAgreementAttributes',
        'billing_agreement_type': 'billingAgreementType',
        'subscription_amount': 'subscriptionAmount',
        'object_type': '@type',
        'version': '@version'
    }
    supports_multiple_types = False

    def __init__(self, platform_id=None, seller_note=None, seller_billing_agreement_attributes=None, billing_agreement_type=None, subscription_amount=None, version=None):


        self.__discriminator_value = "BillingAgreementAttributes"

        self.object_type = self.__discriminator_value
        super(BillingAgreementAttributes, self).__init__(object_type=self.__discriminator_value, version=version)
        self.platform_id = platform_id
        self.seller_note = seller_note
        self.seller_billing_agreement_attributes = seller_billing_agreement_attributes
        self.billing_agreement_type = billing_agreement_type
        self.subscription_amount = subscription_amount

    def to_dict(self):


        result = {}

        for attr, _ in six.iteritems(self.deserialized_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else
                    x.value if isinstance(x, Enum) else x,
                    value
                ))
            elif isinstance(value, Enum):
                result[attr] = value.value
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else
                    (item[0], item[1].value)
                    if isinstance(item[1], Enum) else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):


        return pprint.pformat(self.to_dict())

    def __repr__(self):


        return self.to_str()

    def __eq__(self, other):


        if not isinstance(other, BillingAgreementAttributes):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):


        return not self == other

'alexa-apis-for-python/ask-sdk-model/ask_sdk_model/interfaces/amazonpay/model/request/billing_agreement_type.py'
:














import pprint
import re
import six
import typing
from enum import Enum


if typing.TYPE_CHECKING:
    from typing import Dict, List, Optional, Union, Any
    from datetime import datetime


class BillingAgreementType(Enum):

    CustomerInitiatedTransaction = "CustomerInitiatedTransaction"
    MerchantInitiatedTransaction = "MerchantInitiatedTransaction"

    def to_dict(self):


        result = {self.name: self.value}
        return result

    def to_str(self):


        return pprint.pformat(self.value)

    def __repr__(self):


        return self.to_str()

    def __eq__(self, other):


        if not isinstance(other, BillingAgreementType):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):


        return not self == other

'alexa-apis-for-python/ask-sdk-model/ask_sdk_model/interfaces/amazonpay/request/setup_amazon_pay_request.py'
:














import pprint
import re
import six
import typing
from enum import Enum
from ask_sdk_model.interfaces.amazonpay.model.request.base_amazon_pay_entity import BaseAmazonPayEntity


if typing.TYPE_CHECKING:
    from typing import Dict, List, Optional, Union, Any
    from datetime import datetime
    from ask_sdk_model.interfaces.amazonpay.model.request.billing_agreement_attributes import BillingAgreementAttributes as BillingAgreementAttributes_ec1c47b2


class SetupAmazonPayRequest(BaseAmazonPayEntity):

    deserialized_types = {
        'object_type': 'str',
        'version': 'str',
        'seller_id': 'str',
        'country_of_establishment': 'str',
        'ledger_currency': 'str',
        'checkout_language': 'str',
        'billing_agreement_attributes': 'ask_sdk_model.interfaces.amazonpay.model.request.billing_agreement_attributes.BillingAgreementAttributes',
        'need_amazon_shipping_address': 'bool',
        'sandbox_mode': 'bool',
        'sandbox_customer_email_id': 'str'
    }

    attribute_map = {
        'object_type': '@type',
        'version': '@version',
        'seller_id': 'sellerId',
        'country_of_establishment': 'countryOfEstablishment',
        'ledger_currency': 'ledgerCurrency',
        'checkout_language': 'checkoutLanguage',
        'billing_agreement_attributes': 'billingAgreementAttributes',
        'need_amazon_shipping_address': 'needAmazonShippingAddress',
        'sandbox_mode': 'sandboxMode',
        'sandbox_customer_email_id': 'sandboxCustomerEmailId'
    }
    supports_multiple_types = False

    def __init__(self, version=None, seller_id=None, country_of_establishment=None, ledger_currency=None, checkout_language=None, billing_agreement_attributes=None, need_amazon_shipping_address=False, sandbox_mode=False, sandbox_customer_email_id=None):


        self.__discriminator_value = "SetupAmazonPayRequest"

        self.object_type = self.__discriminator_value
        super(SetupAmazonPayRequest, self).__init__(object_type=self.__discriminator_value, version=version)
        self.seller_id = seller_id
        self.country_of_establishment = country_of_establishment
        self.ledger_currency = ledger_currency
        self.checkout_language = checkout_language
        self.billing_agreement_attributes = billing_agreement_attributes
        self.need_amazon_shipping_address = need_amazon_shipping_address
        self.sandbox_mode = sandbox_mode
        self.sandbox_customer_email_id = sandbox_customer_email_id

    def to_dict(self):


        result = {}

        for attr, _ in six.iteritems(self.deserialized_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else
                    x.value if isinstance(x, Enum) else x,
                    value
                ))
            elif isinstance(value, Enum):
                result[attr] = value.value
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else
                    (item[0], item[1].value)
                    if isinstance(item[1], Enum) else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):


        return pprint.pformat(self.to_dict())

    def __repr__(self):


        return self.to_str()

    def __eq__(self, other):


        if not isinstance(other, SetupAmazonPayRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):


        return not self == other
