{
  "type-to-reducer/src/index.js": "// internal state\nlet typeDelimiter = '_'\n\n// change the string separating action types when reducerMap is nested\nexport const setTypeDelimiter = customTypeDelimiter => typeDelimiter = customTypeDelimiter\n\n// function to concatenate any nested types\nconst _makeType = (prefix, type) => prefix.concat(type).join(typeDelimiter)\n\n// iterator function that will read the reducerMap and return a flattened object\nconst _flattenReducerMap = (reducers, initial={}, prefix=[], customInitialState=null) => {\n  const reducerTypes = Object.keys(reducers || {})\n  return reducerTypes.reduce((acc, type) => {\n    const reducer = reducers[type]\n    const newInitial = customInitialState && customInitialState[type] ? customInitialState[type] : initial\n    return typeof(reducer) === 'function'\n      ? { ...acc, [_makeType(prefix, type)]: (state=newInitial, action) => reducer(state, action) }\n      : _flattenReducerMap(reducer, acc, [ _makeType(prefix, type) ], customInitialState)\n  }, initial)\n}\n\nexport default function typeToReducer(reducerMap, initialState, customInitialState=null) {\n  const flattened = _flattenReducerMap(reducerMap, initialState, [], customInitialState)\n\n  return (state=initialState, action) => {\n    const reducer = flattened[action.type]\n    return reducer ? reducer(state, action) : state\n  }\n}",
  "type-to-reducer/test/index.test.js": "describe('Handle Actions', function() {\n  const fooAction = { type: 'FOO' }\n\n  it('returns a reducer function', ()=> {\n    const state = { test: 'state' }\n    const reducer = typeToReducer()\n    expect(reducer(state, fooAction)).to.eql(state)\n  })\n\n  it('accepts an initialState for the reducer', ()=> {\n    const initialState = { initial: 'state' }\n    const reducer = typeToReducer({}, initialState)\n    expect(reducer(undefined, fooAction)).to.eql(initialState)\n  })\n\n  context('Given A Flat Reducer Config', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: sinon.spy(() => ({ state: 'foo' })),\n        BAR: sinon.spy(() => ({ state: 'bar' })),\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('ignores reducers when no matching type', ()=> {\n      const differentAction = { type: 'DIFFERENT' }\n      const newState = this.reducer(undefined, differentAction)\n      expect(newState).to.eql(initialState)\n      expect(this.reducerConfig.FOO).to.have.callCount(0)\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('calls the reducer mapped to the action type', ()=> {\n      const state = { given: 'state' }\n      this.reducer(state, fooAction)\n      expect(this.reducerConfig.FOO).to.have.callCount(1)\n      expect(this.reducerConfig.FOO).to.have.been.calledWith(\n        state, fooAction\n      )\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('returns the value from the called reducer', ()=> {\n      const actual = this.reducer({}, fooAction)\n      const expected = this.reducerConfig.FOO()\n      expect(actual).to.eql(expected)\n    })\n  })\n\n  context('Given A Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooHerpAction = { type: 'FOO_HERP' }\n      this.reducer(state, fooHerpAction)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.HERP).to.have.been.calledWith(\n        state, fooHerpAction\n      )\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO_DERP_BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n\n  context('Given A Custom Type Delimiter Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      setTypeDelimiter('|')\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO|DERP|BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n\n  context('Given Custom Initial State Per Action Type', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: sinon.spy(() => ({ state: 'foo' })),\n        BAR: sinon.spy(() => ({ state: 'bar' })),\n      }\n      this.customInitialState = {\n        FOO: { custom: 'foo' },\n        BAR: { custom: 'bar' },\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState, this.customInitialState)\n    })\n\n    it('uses custom initial state for FOO action', ()=> {\n      const actual = this.reducer(undefined, fooAction)\n      const expected = this.reducerConfig.FOO(this.customInitialState.FOO, fooAction)\n      expect(actual).to.eql(expected)\n    })\n\n    it('uses custom initial state for BAR action', ()=> {\n      const barAction = { type: 'BAR' }\n      const actual = this.reducer(undefined, barAction)\n      const expected = this.reducerConfig.BAR(this.customInitialState.BAR, barAction)\n      expect(actual).to.eql(expected)\n    })\n  })\n}"
}
