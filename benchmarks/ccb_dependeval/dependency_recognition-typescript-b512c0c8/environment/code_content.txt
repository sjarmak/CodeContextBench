'predicates/src/typeToPredicate.ts'
:import isString from './string';
import isBoolean from './boolean';
import isNumber from './number';
import {Predicate} from './types';
import isSymbol from './symbol';
import isWeakMap from './weakMap';
import isWeakSet from './weakSet';
import isRegExp from './regexp';
import isObject from './object';
import isFunction from './function';
import isDate from './date';
import isArray from './array';

const find = require('array-find');

const mapping: [Function, Predicate][] = [
    [String, isString],
    [Boolean, isBoolean],
    [Number, isNumber],
    [RegExp, isRegExp],
    [Object, isObject],
    [Function, isFunction],
    [Date, isDate],
    [Array, isArray]
];

if (typeof Symbol !== 'undefined') {
    mapping.push([Symbol, isSymbol]);
}

if (typeof WeakMap !== 'undefined') {
    mapping.push([WeakMap, isWeakMap]);
}

if (typeof WeakSet !== 'undefined') {
    mapping.push([WeakSet, isWeakSet]);
}


export function getPredicateForType(type: Function): Predicate {
    const result = find(mapping, (entry: [Function, Predicate]) => {
        return entry[0] === type;
    });

    if (result) {
        return result[1];
    }
}
'predicates/src/any.ts'
:import {Predicate} from './types';
import assertPredicates from './utils/assertPredicates';
import {getDescription, setDescription} from './utils/description';
import {getPredicateForType} from './typeToPredicate';


export default function any(...predicates: (Predicate | Function)[]): Predicate {
    const convertedPredicates = predicates.map((p) => getPredicateForType(p) || <Predicate>p);
    assertPredicates(convertedPredicates);

    return setDescription(
        function anyPredicate() {
            const args = arguments;
            return convertedPredicates.some(predicate => predicate.apply(this, args));
        },
        'a value that satisfies any of predicates: ' + (convertedPredicates.map(getDescription)).join(', ')
    );
}
'predicates/test/anyTest.ts'
:import any from '../src/any';
import {assert} from 'chai';
import * as sinon from 'sinon';
import {assertDescription, falsePredicate, truePredicate} from "./common";
import isString from "../src/string";
import isNumber from "../src/number";

describe('any', function () {


    it('returns a function', function () {
        assert.isFunction(any(truePredicate, falsePredicate));
    });

    it('throws error if not every predicate is a function', function () {
        assert.throws(function () {
            any(truePredicate, <any>'definitely not a function');
        });
    });

    it('throws error if zero or only one predicate provided', function () {
        assert.throws(function () {
            any();
        }, Error, 'need to provide at least two predicates');

        assert.throws(function () {
            any(truePredicate);
        }, Error, 'need to provide at least two predicates');

        assert.doesNotThrow(function () {
            any(truePredicate, falsePredicate);
        });
    });

    it('calls predicates in order', function () {
        const p1 = sinon.stub().returns(false);
        const p2 = sinon.stub().returns(false);
        const p3 = sinon.stub().returns(false);
        const value = 'value';

        any(p1, p2, p3)(value);

        sinon.assert.calledWith(p1, value);
        sinon.assert.calledWith(p2, value);
        sinon.assert.calledWith(p3, value);

        assert.ok(p1.calledBefore(p2));
        assert.ok(p2.calledBefore(p3));
    });

    it('calls predicates with correct context and arguments', function () {
        const args = [1, 2, 3, 4];
        const context = {example: 'context'};
        const stub = sinon.stub().returns(false);
        const testPredicate = any(stub, stub, stub, stub);

        assert.isFalse(testPredicate.apply(context, args));

        sinon.assert.callCount(stub, 4);
        sinon.assert.alwaysCalledOn(stub, context);
        sinon.assert.calledWith(stub, ...args);
    });

    it('checks whether at least one predicate has been satisfied', function () {
        assert.isTrue(any(falsePredicate, truePredicate, falsePredicate)('value'));
        assert.isFalse(any(falsePredicate, falsePredicate)('value'));
    });

    it('does not call all predicates if one of them has been satisfied earlier', function () {
        assert.isTrue(any(truePredicate, function () {
            throw new Error('Last predicate should not be called');
        })('value'));
    });

    it('description', () => {
        assertDescription(any(isString, isNumber), 'a value that satisfies any of predicates: a string, a number')
    });

    it('for simple types', () => {
        const noop = function () {
        };
        assert.isTrue(any(String, falsePredicate)('test'));
        assert.isTrue(any(Boolean, falsePredicate)(false));
        assert.isTrue(any(RegExp, falsePredicate)(/a/));
        assert.isTrue(any(Object, falsePredicate)({test: 1}));
        assert.isTrue(any(Function, falsePredicate)(noop));
        assert.isTrue(any(Date, falsePredicate)(new Date()));
        assert.isTrue(any(Array, falsePredicate)([]));
    })
});

'predicates/src/weakSet.ts'
:import {setDescription} from './utils/description';


export default function isWeakSet<T extends object = any>(value: any): value is WeakSet<T> {
    return typeof WeakSet !== 'undefined' && value instanceof WeakSet;
}

setDescription(isWeakSet, 'a WeakSet');

'predicates/src/utils/assertPredicates.ts'
:import {Predicate} from "../types";
import isFunction from '../function';
import isArrayOf from '../arrayOf';

export default function assertPredicates(predicates: Predicate[]) {
    if (!isArrayOf(isFunction, predicates)) {
        throw new TypeError('Every predicate must be a function');
    }
    if (predicates.length < 2) {
        throw new Error('You need to provide at least two predicates');
    }
}


'predicates/src/arrayOf.ts'
:import {Predicate, TypeGuardPredicate} from './types';

import isArray from './array';
import isFunction from './function';
import handleCurry from './utils/handleCurry';
import {getDescription, setDescription} from './utils/description';
import {getPredicateForType} from './typeToPredicate';


function isArrayOf<T = any>(predicate: Predicate | Function): TypeGuardPredicate<Array<T>>;
function isArrayOf<T = any>(predicate: Predicate | Function, value: any[]): value is Array<T>;
function isArrayOf<T>(predicate: Predicate | Function, value?: any[], ...extraArgs: any[]): boolean | TypeGuardPredicate<Array<T>> {
    if (!isFunction(predicate)) {
        throw new TypeError('Predicate must be a function');
    }

    predicate = getPredicateForType(predicate) || predicate;

    return handleCurry.call(this, arguments,
        setDescription(function (value: any) {
                const match = (value: any) => predicate.apply(this, [value].concat(extraArgs));
                return isArray(value) && value.every(match);
            },
            'an array of elements of type: ' + getDescription(<Predicate>predicate)
        )
    );
}

export default isArrayOf;