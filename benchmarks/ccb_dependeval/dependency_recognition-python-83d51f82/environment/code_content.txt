'xos/lib/xos-synchronizer/xossynchronizer/backend.py'
:













from __future__ import absolute_import, print_function

import imp
import inspect
import os
import sys
import threading
import time

from multistructlog import create_logger
from xosconfig import Config
from xossynchronizer.event_engine import XOSEventEngine
from xossynchronizer.event_loop import XOSObserver
from xossynchronizer.model_policy_loop import XOSPolicyEngine
from xossynchronizer.pull_step_engine import XOSPullStepEngine

log = create_logger(Config().get("logging"))


class Backend:
    def __init__(self, model_accessor, log=log):
        self.model_accessor = model_accessor
        self.log = log

    def load_sync_step_modules(self, step_dir):
        sync_steps = []

        self.log.info("Loading sync steps", step_dir=step_dir)

        for fn in os.listdir(step_dir):
            pathname = os.path.join(step_dir, fn)
            if (
                os.path.isfile(pathname)
                and fn.endswith(".py")
                and (fn != "__init__.py")
                and (not fn.startswith("test"))
            ):


                sys_path_save = sys.path
                sys.path.append(step_dir)
                module = imp.load_source(fn[:-3], pathname)

                self.log.debug("Loaded file: %s", pathname)


                sys.path = sys_path_save

                for classname in dir(module):
                    c = getattr(module, classname, None)








                    if inspect.isclass(c):
                        bases = inspect.getmro(c)
                        base_names = [b.__name__ for b in bases]
                        if (
                            ("SyncStep" in base_names)
                            and (hasattr(c, "provides") or hasattr(c, "observes"))
                            and (c not in sync_steps)
                        ):
                            sync_steps.append(c)

        self.log.info("Loaded sync steps", steps=sync_steps)

        return sync_steps

    def run(self):
        observer_thread = None
        model_policy_thread = None
        event_engine = None

        steps_dir = Config.get("steps_dir")
        if steps_dir:
            sync_steps = []


            if steps_dir:
                sync_steps = self.load_sync_step_modules(steps_dir)


            if len(sync_steps) > 0:

                self.log.info(
                    "Starting XOSObserver",
                    sync_steps=sync_steps,
                    model_accessor=self.model_accessor,
                )
                observer = XOSObserver(sync_steps, self.model_accessor, self.log)
                observer_thread = threading.Thread(
                    target=observer.run, name="synchronizer"
                )
                observer_thread.start()

        else:
            self.log.info("Skipping observer thread due to no steps dir.")

        pull_steps_dir = Config.get("pull_steps_dir")
        if not pull_steps_dir:
            self.log.info("Skipping pull step engine due to no pull_steps_dir dir.")
        elif Config.get("desired_state") == "unload":
            self.log.info("Skipping pull steps engine due to synchronizer unloading.")
        else:
            self.log.info("Starting XOSPullStepEngine", pull_steps_dir=pull_steps_dir)
            pull_steps_engine = XOSPullStepEngine(model_accessor=self.model_accessor)
            pull_steps_engine.load_pull_step_modules(pull_steps_dir)
            pull_steps_thread = threading.Thread(
                target=pull_steps_engine.start, name="pull_step_engine"
            )
            pull_steps_thread.start()

        event_steps_dir = Config.get("event_steps_dir")
        if not event_steps_dir:
            self.log.info("Skipping event engine due to no event_steps dir.")
        elif Config.get("desired_state") == "unload":
            self.log.info("Skipping event engine due to synchronizer unloading.")
        else:
            self.log.info("Starting XOSEventEngine", event_steps_dir=event_steps_dir)
            event_engine = XOSEventEngine(
                model_accessor=self.model_accessor, log=self.log
            )
            event_engine.load_event_step_modules(event_steps_dir)
            event_engine.start()


        policies_dir = Config.get("model_policies_dir")
        if policies_dir:
            policy_engine = XOSPolicyEngine(
                policies_dir=policies_dir,
                model_accessor=self.model_accessor,
                log=self.log,
            )
            model_policy_thread = threading.Thread(
                target=policy_engine.run, name="policy_engine"
            )
            model_policy_thread.is_policy_thread = True
            model_policy_thread.start()
        else:
            self.log.info(
                "Skipping model policies thread due to no model_policies dir."
            )

        if (not observer_thread) and (not model_policy_thread) and (not event_engine):
            self.log.info(
                "No sync steps, no policies, and no event steps. Synchronizer exiting."
            )

            return

        while True:
            try:
                time.sleep(1000)
            except KeyboardInterrupt:
                print("exiting due to keyboard interrupt")

                if observer_thread:
                    observer_thread._Thread__stop()
                if model_policy_thread:
                    model_policy_thread._Thread__stop()
                sys.exit(1)

'xos/lib/xos-synchronizer/xossynchronizer/synchronizer.py'
:













from __future__ import absolute_import

import time

from multistructlog import create_logger
from xosconfig import Config


class Synchronizer(object):
    def __init__(self):
        self.log = create_logger(Config().get("logging"))

    def create_model_accessor(self):
        from .modelaccessor import model_accessor

        self.model_accessor = model_accessor

    def wait_for_ready(self):
        models_active = False
        wait = False
        while not models_active:
            try:

                _i = self.model_accessor.Site.objects.first()
                models_active = True
            except Exception as e:
                self.log.info("Exception", e=e)
                self.log.info("Waiting for data model to come up before starting...")
                time.sleep(10)
                wait = True

        if wait:
            time.sleep(
                60
            )

    def run(self):
        self.create_model_accessor()
        self.wait_for_ready()





        from .backend import Backend

        log_closure = self.log.bind(synchronizer_name=Config().get("name"))
        backend = Backend(log=log_closure, model_accessor=self.model_accessor)
        backend.run()

'xos/testservice/xos/synchronizer/testservice-synchronizer.py'
:

















from __future__ import absolute_import

import os
from xossynchronizer import Synchronizer
from xosconfig import Config


def main():
    base_config_file = os.path.abspath(os.path.dirname(
        os.path.realpath(__file__)) + '/config.yaml')
    mounted_config_file = os.path.abspath(os.path.dirname(
        os.path.realpath(__file__)) + '/mounted_config.yaml')

    if os.path.isfile(mounted_config_file):
        Config.init(base_config_file, 'synchronizer-config-schema.yaml',
                    mounted_config_file)
    else:
        Config.init(base_config_file, 'synchronizer-config-schema.yaml')

    Synchronizer().run()


if __name__ == "__main__":
    main()

'xos/lib/xos-synchronizer/xossynchronizer/event_engine.py'
:













from __future__ import absolute_import

import imp
import inspect
import os
import threading
import time

import confluent_kafka

from xosconfig import Config


class XOSKafkaMessage:
    def __init__(self, consumer_msg):

        self.topic = consumer_msg.topic()
        self.key = consumer_msg.key()
        self.value = consumer_msg.value()

        self.timestamp = None
        (ts_type, ts_val) = consumer_msg.timestamp()

        if ts_type is not confluent_kafka.TIMESTAMP_NOT_AVAILABLE:
            self.timestamp = ts_val


class XOSKafkaThread(threading.Thread):


    def __init__(self, step, bootstrap_servers, model_accessor, log, *args, **kwargs):
        super(XOSKafkaThread, self).__init__(*args, **kwargs)
        self.consumer = None
        self.step = step
        self.bootstrap_servers = bootstrap_servers
        self.model_accessor = model_accessor
        self.log = log
        self.daemon = True

    def create_kafka_consumer(self):

        consumer_config = {
            "group.id": Config().get("name"),
            "bootstrap.servers": ",".join(self.bootstrap_servers),
            "default.topic.config": {"auto.offset.reset": "smallest"},
        }

        return confluent_kafka.Consumer(**consumer_config)

    def run(self):
        if (not self.step.topics) and (not self.step.pattern):
            raise Exception(
                "Neither topics nor pattern is defined for step %s" % self.step.__name__
            )

        if self.step.topics and self.step.pattern:
            raise Exception(
                "Both topics and pattern are defined for step %s. Choose one."
                % self.step.__name__
            )

        self.log.info(
            "Waiting for events",
            topic=self.step.topics,
            pattern=self.step.pattern,
            step=self.step.__name__,
        )

        while True:
            try:

                if self.consumer is None:
                    self.consumer = self.create_kafka_consumer()

                    if self.step.topics:
                        self.consumer.subscribe(self.step.topics)

                    elif self.step.pattern:
                        self.consumer.subscribe(self.step.pattern)

            except confluent_kafka.KafkaError._ALL_BROKERS_DOWN as e:
                self.log.warning(
                    "No brokers available on %s, %s" % (self.bootstrap_servers, e)
                )
                time.sleep(20)
                continue

            except confluent_kafka.KafkaError as e:

                self.log.exception("Exception in kafka loop: %s" % e)
                time.sleep(1)
                continue


            msg = self.consumer.poll(timeout=1.0)

            if msg is None:
                continue

            if msg.error():
                if msg.error().code() == confluent_kafka.KafkaError._PARTITION_EOF:
                    self.log.debug(
                        "Reached end of kafka topic %s, partition: %s, offset: %d"
                        % (msg.topic(), msg.partition(), msg.offset())
                    )
                else:
                    self.log.exception("Error in kafka message: %s" % msg.error())

            else:

                event_msg = XOSKafkaMessage(msg)

                self.log.info(
                    "Processing event", event_msg=event_msg, step=self.step.__name__
                )

                try:
                    self.step(
                        model_accessor=self.model_accessor, log=self.log
                    ).process_event(event_msg)

                except BaseException:
                    self.log.exception(
                        "Exception in event step",
                        event_msg=event_msg,
                        step=self.step.__name__,
                    )


class XOSEventEngine(object):


    def __init__(self, model_accessor, log):
        self.event_steps = []
        self.threads = []
        self.model_accessor = model_accessor
        self.log = log

    def load_event_step_modules(self, event_step_dir):
        self.event_steps = []
        self.log.info("Loading event steps", event_step_dir=event_step_dir)


        for fn in os.listdir(event_step_dir):
            pathname = os.path.join(event_step_dir, fn)
            if (
                os.path.isfile(pathname)
                and fn.endswith(".py")
                and (fn != "__init__.py")
                and ("test" not in fn)
            ):
                event_module = imp.load_source(fn[:-3], pathname)

                for classname in dir(event_module):
                    c = getattr(event_module, classname, None)

                    if inspect.isclass(c):
                        base_names = [b.__name__ for b in c.__bases__]
                        if "EventStep" in base_names:
                            self.event_steps.append(c)
        self.log.info("Loaded event steps", steps=self.event_steps)

    def start(self):
        eventbus_kind = Config.get("event_bus.kind")
        eventbus_endpoint = Config.get("event_bus.endpoint")

        if not eventbus_kind:
            self.log.error(
                "Eventbus kind is not configured in synchronizer config file."
            )
            return

        if eventbus_kind not in ["kafka"]:
            self.log.error(
                "Eventbus kind is set to a technology we do not implement.",
                eventbus_kind=eventbus_kind,
            )
            return

        if not eventbus_endpoint:
            self.log.error(
                "Eventbus endpoint is not configured in synchronizer config file."
            )
            return

        for step in self.event_steps:
            if step.technology == "kafka":
                thread = XOSKafkaThread(
                    step, [eventbus_endpoint], self.model_accessor, self.log
                )
                thread.start()
                self.threads.append(thread)
            else:
                self.log.error(
                    "Unknown technology. Skipping step",
                    technology=step.technology,
                    step=step.__name__,
                )

'xos/lib/xos-synchronizer/xossynchronizer/__init__.py'
:













from __future__ import absolute_import
from .synchronizer import Synchronizer

__all__ = ["Synchronizer"]
